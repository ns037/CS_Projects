# -*- coding: utf-8 -*-
"""American Multi-step Binomial_model.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1RLSra2GG1wli5wnTehkZfXPgL0GIYawi
"""

import math as math
import numpy as np
import matplotlib as plt

# american options pricing binomial model

# n -> number of steps
# t -> total time period in years
# s_not -> stock price at t = 0
# u -> the ratio by which the stock goes up per dt
# d -> the ratio by which the stock goes down per dt
# E -> strike price
# r -> interest rate in decimal point, i.e, 4% = 0.04( pass this on as the argument)
#type -> type either 'C' or 'P'

# a function that returns the price of an option at time t = 0 for an option.
def binomial(t, n, s_not, sigma, E,r, type):

  dt = t / n

  u = math.exp(sigma*math.sqrt(dt))
  d = 1/u
# if n steps the lattice has n+1*n+1 dimensions:
  matrix = np.zeros((n+1, n+1))
  #the first entry is the stock price at t = 0
  matrix[0,0] = s_not

  # setting up the values of the lattice 
  for i in range(n+1):
    for j in range(i+1,n+1):
          matrix[i,j] = u*matrix[i,j-1]
          matrix[i+1,j] = d*matrix[i,j-1]
  # print('------binomial lattice------\n')
  # print(matrix)

# by looking at the type of the option, the appropriate payoff matrix generating function is called
  if type =='C':
    name = "Call"
    mat = call_option_payoff(matrix,E,s_not)
  else:
    name = "Put"
    mat = put_option_payoff(matrix, E, s_not)  
  # print(f"\n-----binomial lattice with just payoffs of a {name} option----- \n")
  # print(np.round(mat,2))

  # calculating p* and q*
  p = (math.exp(r*dt)-d)/(u-d)
  q = (u - math.exp(r*dt))/(u-d)

# calculate the option price and return the current price of the option (which is at [0,0])
  return option_price(r,n,dt,mat,p,q,matrix,E)[0,0]

# use the binomial lattice to calculate the payoff matrix of a call option
#NOTE: can have a single function for both call and put options by simply introducing a new parameter for the type of option being priced
def call_option_payoff(matrix, E, s_not):
  payoff =  matrix - E
  payoff[0,0] = s_not
  result = np.where(payoff<0, 0, payoff)
  return result

# use the binomial lattice to calculate the payoff matrix of a put option
def put_option_payoff(matrix, E, s_not):
  payoff = E - matrix
  payoff[0,0] = s_not
  result = np.where(payoff<0, 0, payoff)
  return result

# perfrom an option price calculation on the payoff matrix by going backwards. [0,0] index has the price at t = 0.
#stores every intermediate step value at the respective matrix indices.

def option_price(r,n, dt, final_matrix,p,q, matrix,E):

  # fix a column and calculate all the valus for that column
  for j in range(n-1,0,-1):
    for i in range(0, j+1): 
      # recurrence of american options 
      final_matrix[i,j] = max(final_matrix[i,j],math.exp(-r*dt)*(p*final_matrix[i,j+1] + q*final_matrix[i+1,j+1]))
  
  final_matrix[0,0] = math.exp(-r*dt)*(p*final_matrix[0,1]+ q*final_matrix[1,1])
  # print("\n---------final matrix --------------")
  # print(np.round(final_matrix,2))
  return final_matrix

# testing using the example from the book

mat = binomial(5/12, 1000, 50, 0.4, 50, 0.05,'P')

print(f'\n final price is : ${np.round(mat,4)}')

# testing for google (GOOG)
# test_case : call option for april 21st, 16 days 
#Contract Name	        Last Trade Date	    Strike	Last Price	Bid	    Ask	   Change	% Change	Volume	Open Interest	Implied Volatility
#GOOG230421C00045000	2023-03-22 9:54AM EDT	45.00	  59.45	      57.90	  62.00	  0.00	                      -	1	13	50.00%

s_not = 104.95
r =0.0477 # 3 month treasury yield 
final_price = 59.45
mat = binomial(16/365, 2000, s_not, 0.5, 45, r,'C')
fair_price = np.round(mat,2)
print(f'\n fair price is : ${fair_price}')
print('difference between final price and fair price ',round((final_price - fair_price ),2))

# testing for google (GOOG) april 5th 
# test_case : call option for June 21st 2024, 442 days 
#Contract Name	        Last Trade Date	    Strike	Last Price	Bid	    Ask	   Change	% Change	Volume	Open Interest	Implied Volatility
#GOOG240621C00050000	2023-03-29 1:28PM EDT	50.00	  55.85	      56.50	  61.00 	0.00	                      -	2	204	              64.47%

s_not = 104.95
r =0.0477 # 3 month treasury yield april 5th
final_price = 55.85
mat = binomial(442/365, 2000, s_not, 0.6447, 50, r,'C')
fair_price = np.round(mat,2)
print(f'\n fair price is : ${fair_price}')
print('difference between final price and fair price ',round((final_price - fair_price ),2))

#AMZN230818C00060000	2023-03-30 10:59AM EDT	60.00	44.00	43.45	43.90	0.00	-	1	12	69.63%
#in the money amazon stocks (april 6th) expiry august 18th 2023 134 days

s_not = 102.06
r =0.0472 # 3 month treasury yield april 6th
final_price = 44.00
mat = binomial(134/365, 2000, s_not, 0.6963, 60.00, r,'C')
fair_price = np.round(mat,2)
print(f'\n fair price is : ${fair_price}')
print('difference between final price and fair price ',round((final_price - fair_price ),2))

#AMZN230818C00100000	2023-04-06 3:39PM EDT	100.00	11.67	11.60	11.75	+0.47	+4.20%	112	1,981	43.89%
#in the money amazon stocks (april 6th) expiry august 18th 2023 134 days

s_not = 102.06
r =0.0472 # 3 month treasury yield april 6th
final_price = 11.67
mat = binomial(134/365, 2000, s_not, 0.4389, 100.00, r,'C')
fair_price = np.round(mat,2)
print(f'\n fair price is : ${fair_price}')
print('difference between final price and fair price ',round((final_price - fair_price ),2))

#META230512C00220000	2023-04-06 3:58PM EDT	220.00	12.18	11.10	13.40	+2.28	+23.03%	16	229	51.72%
# out of money april 6th META  call options
s_not = 216.10
r =0.0472 # 3 month treasury yield april 6th - may12 2023 36 days
final_price = 12.18
mat = binomial(36/365, 2000, s_not, 0.5172, 220.00, r,'C')
fair_price = np.round(mat,2)
print(f'\n fair price is : ${fair_price}')
print('difference between final price and fair price ',round((final_price - fair_price ),2))

#META230512C00240000	2023-04-06 3:07PM EDT	240.00	5.20	5.10	5.25	+1.00	+23.81%	70	179	49.41%
# out of money april 6th META  call options
s_not = 216.10
r =0.0472 # 3 month treasury yield april 6th - may12 2023 36 days
final_price = 5.20
mat = binomial(36/365, 2000, s_not, 0.4941, 240.00, r,'C')
fair_price = np.round(mat,2)
print(f'\n fair price is : ${fair_price}')
print('difference between final price and fair price ',round((final_price - fair_price ),2))

#ADBE230428P00400000	2023-04-04 2:00PM EDT	400.00	19.05	21.35	22.10	0.00	-	1	4	24.54%
# in the money april 6th adobe  put option ( april 28 2023 22 days)
s_not = 380.60
r =0.0472 # 3 month treasury yield april 6th
final_price = 19.05
mat = binomial(22/365, 2000, s_not, 0.2454, 400.00, r,'P')
fair_price = np.round(mat,2)
print(f'\n fair price is : ${fair_price}')
print('difference between final price and fair price ',round((final_price - fair_price ),2))

#ADBE230428P00355000	2023-04-06 12:42PM EDT	355.00	2.64	2.61	2.81	-0.19	-6.71%	6	85	31.32%
# out of money april 6th adobe  put option ( april 28 2023 22 days)
s_not = 380.60
n = [10,20,50,100,250,500,750,1000]
plot_dict = {}
r =0.0472 # 3 month treasury yield april 6th 
final_price = 2.64
for steps in n: 
  mat = binomial(22/365, steps, s_not, 0.3132, 355.00, r,'P')
  fair_price = np.round(mat,2)  
  print(f'\n fair price is : ${fair_price}')
  print('difference between final price and fair price ',round((final_price - fair_price ),2))
  plot_dict[str(steps)] = round(abs(final_price - fair_price ),6)

x = list(plot_dict.keys())
y = list(plot_dict.values())
plt.scatter(x,y)

plt.show()

#NFLX240621P00250000	2023-04-03 1:36PM EDT	250.00	21.10	21.15	23.45	0.00	-	20	217	45.18%
#out of money netflix stock put option april 6th - june21 2024 441 days
s_not = 339.33
n = [10,20,50,100,250,500,750,1000]
r =0.0472 # 3 month treasury yield april 6th
final_price = 21.10
plot_dict = {}
for steps in n:
  mat = binomial(441/365, steps, s_not, 0.4518, 250.00, r,'P')
  fair_price = np.round(mat,2)
  print(f'\n fair price is : ${fair_price}')
  print('difference between final price and fair price ',round((final_price - fair_price ),2))
  plot_dict[str(steps)] = round(abs(final_price - fair_price ),6)

x = list(plot_dict.keys())
y = list(plot_dict.values())
plt.scatter(x,y)

plt.show()

#NFLX240621C00250000	2023-04-05 2:01PM EDT	250.00	126.58	124.00	127.40	0.00	-	2	432	57.36%
#in the money netflix stock call option april 6th - june21 2024 441 days
s_not = 339.33
n = [10,20,50,100,500,1000,2000, 2500]
r =0.0472 # 3 month treasury yield april 6th
final_price = 126.58
plot_dict = {}
for steps in n:
  mat = binomial(441/365, steps, s_not, 0.5736, 250.00, r,'C')
  fair_price = np.round(mat,2)
  print(f'\n fair price is : ${fair_price}')
  print('difference between final price and fair price ',round((final_price - fair_price ),2))
  plot_dict[str(steps)] = round(abs(final_price - fair_price ),6)

x = list(plot_dict.keys())
y = list(plot_dict.values())
plt.scatter(x,y)
plt.show()

"""Here, we observe convergence, upto 6 significant figures around n = 500 steps. Again, we observe that unsually low systematic error at n = 20. """

#AMZN230818C00060000	2023-03-30 10:59AM EDT	60.00	44.00	43.45	43.90	0.00	-	1	12	69.63%
#in the money amazon stocks (april 6th) expiry august 18th 2023 134 days

plot_dict = {}
n = [10,20,50,100,500,1000,2000, 2500]
s_not = 102.06
r =0.0472 # 3 month treasury yield april 6th
final_price = 44.00
for steps in n:
  mat = binomial(134/365, steps, s_not, 0.6963, 60.00, r,'C')
  fair_price = np.round(mat,2)
  print(f'\n fair price is : ${fair_price}')
  print('difference between final price and fair price ',round((final_price - fair_price ),2))
  plot_dict[str(steps)] = round(abs(final_price - fair_price ),6)

x = list(plot_dict.keys())
y = list(plot_dict.values())
plt.scatter(x,y)
plt.show()



